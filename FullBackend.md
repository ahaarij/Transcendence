# Full Backend Guide (Transcendence)

This document teaches the backend stack used in this project from first principles to practical execution. It is written as a mini-course you can follow end-to-end.

---
## 1) Big-Picture Architecture
- **Frontend (Vite)** serves the SPA; talks to backend via HTTPS and WebSockets.
- **Backend gateway (Fastify)** exposes `/auth`, `/user`, `/game` HTTP APIs on port 3000 (inside Docker).
- **Microservices (split codepaths)** live inside the same repo: `auth`, `user`, `game`, `ws-gateway` (websocket router). In production you could run them separately; here they are combined behind one Fastify instance for HTTP plus a separate WS gateway.
- **Database (SQLite + Prisma)** stored at `srcs/backend/prisma/dev.db` via Prisma ORM.
- **Nginx reverse proxy + SSL** terminates HTTPS on port 443 and forwards to backend/front/WS on the Docker bridge network.
- **Docker Compose** wires everything with an isolated **bridge network** (virtual switch) so containers reach each other by service name.

Text diagram (inside Docker):
```
[Browser] --HTTPS--> [nginx:443] --http--> [backend:3000]
                                   \--ws--> [ws-gateway:3004]
                                   \--http--> [frontend:8080]
[SQLite file on volume] <--> [backend]
```

---
## 2) Core Concepts You Need
- **Bridge network (Docker)**: a virtual Layer-2 switch Docker creates so containers can talk using service names (e.g., `http://backend:3000`). It isolates traffic from your host LAN.
- **Reverse proxy (Nginx)**: front door that handles TLS (certs/keys), HTTP→HTTPS redirect, static headers, and routes paths to internal services.
- **JWT (JSON Web Token)**: a signed JSON blob used for stateless auth. Contains claims like `{ userId: "uuid" }`. Signed with `JWT_ACCESS_SECRET` so the server can verify integrity without DB lookups.
- **Fastify**: a fast Node.js web framework. Provides routing, plugins, typed replies, and integrates with `@fastify/jwt` and CORS.
- **Prisma ORM**: schema-first data modeling; generates a type-safe client. Here it targets SQLite (file DB). `prisma/schema.prisma` defines models; `prisma generate` makes the client; `prisma db push` syncs schema.
- **SQLite**: lightweight file database, perfect for local/dev. Stored in the container (or mounted volume) at `prisma/dev.db`.
- **WebSockets**: full-duplex channel for real-time game updates. Implemented in `ws-gateway` using `@fastify/websocket`.
- **CORS**: Cross-Origin Resource Sharing. Backend allows the frontend origin so the browser can call APIs with cookies/headers.
- **Self-signed certs (dev)**: generated by `srcs/nginx/generate-ssl-cert.sh`; browsers warn because the issuer is not trusted. Accept for local dev.

---
## 3) Repo Layout (backend-focused)
- `srcs/backend/main.ts` – Fastify app that registers all HTTP routes (auth, user, game).
- `srcs/backend/shared/fastify.ts` – Fastify factory with CORS + static files.
- `srcs/backend/shared/utils/prisma.ts` – Prisma client plugin (SQLite adapter).
- `srcs/backend/auth/*` – Auth routes (register/login/logout/google/twofa), token utils, password utils.
- `srcs/backend/user/*` – User profile endpoints.
- `srcs/backend/game/*` – Game result recording endpoints.
- `srcs/backend/ws-gateway/*` – WebSocket gateway for real-time play.
- `srcs/backend/prisma/schema.prisma` – Data model (User uses UUID ids, Match uses autoincrement int for matches).
- `srcs/nginx/*` – Nginx config, Dockerfile, SSL generator.
- `srcs/docker-compose.yml` – Services: nginx, backend, frontend, ws-gateway, bridge network, volumes.

---
## 4) Data Model (Prisma)
```prisma
model User {
  id               String   @id @default(uuid()) // UUID primary key
  username         String   @unique
  email            String   @unique
  password         String?
  refreshToken     String?
  googleId         String?  @unique
  avatar           String?
  twoFactorSecret  String?
  twoFactorEnabled Boolean  @default(false)
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
  matches          Match[]  @relation("UserMatches")
}

model Match {
  id              Int      @id @default(autoincrement())
  userId          String
  user            User     @relation("UserMatches", fields: [userId], references: [id])
  opponentId      String
  userSide        Int
  userScore       Int
  opponentScore   Int
  didUserWin      Boolean
  gameMode        String
  tournamentSize  Int?
  tournamentRound Int?
  isEliminated    Boolean?
  playedAt        DateTime @default(now())
}
```
- **UUID user IDs**: avoid predictable incremental IDs for security.
- **Autoincrement match IDs**: fine for internal use and ordering.

---
## 5) Auth Flow (JWT)
1) **Login / Google / Register** issues two tokens:
   - Access token: short-lived (~15m), in Authorization header.
   - Refresh token: longer-lived (~7d), to mint new access tokens.
2) **Protected routes** verify `Authorization: Bearer <token>` using `@fastify/jwt` and the shared secret `JWT_ACCESS_SECRET`.
3) **Token payload** includes `userId` (UUID). No password data inside the token.
4) **2FA (TOTP)** optional: secrets stored per user; verification during sensitive actions.

JWT integrity: signature is `HMAC_SHA256(secret, header.payload)`. The server recomputes to verify; tampering breaks the signature. Math note: verification checks equality of the MAC; security relies on secret entropy.

---
## 6) Services and Responsibilities
- **Auth service (`/auth/*`)**: register, login, Google OAuth token exchange, refresh, logout, 2FA enable/verify/disable, delete account.
- **User service (`/user/*`)**: public profiles, update profile (username/avatar), internal get by id.
- **Game service (`/game/*`)**: record matches, fetch history (per user).
- **WS Gateway (`/ws/game`)**: authenticate first message via JWT, keep a map of `userId -> socket`, relay real-time game messages.

---
## 7) Nginx & HTTPS
- Listens on **80** (redirect) and **443** (TLS).
- Uses certs at `/etc/nginx/ssl/server.crt` and `/etc/nginx/ssl/server.key` (mounted from `srcs/nginx/ssl`).
- Proxies:
  - `/auth`, `/user`, `/game`, `/public` → backend:3000
  - `/ws/*` → ws-gateway:3004 (with Upgrade headers)
  - `/` → frontend:8080
- Security headers: HSTS, X-Frame-Options, X-Content-Type-Options, X-XSS-Protection.
- Dev certs: run `srcs/nginx/generate-ssl-cert.sh` (self-signed → browser warning is expected).

---
## 8) Docker & Networking
- **Compose file** defines services and a **bridge network** `transcendence-network`.
- Services talk via DNS names: `backend`, `frontend`, `ws-gateway`, `nginx`.
- Ports exposed to host: `80:80`, `443:443`. Backend/Frontend/WS only exposed internally via `expose`.
- Volumes: `backend-uploads` for static uploads.

---
## 9) Environment Variables (key ones)
- `JWT_ACCESS_SECRET`, `JWT_REFRESH_SECRET` – crypto secrets; use long random strings.
- `GOOGLE_CLIENT_ID`, `GOOGLE_CLIENT_SECRET` – Google OAuth credentials.
- `CORS_ORIGIN` – set to `https://localhost` for dev with nginx.
- `VITE_API_BASE_URL` – frontend base URL, `https://localhost`.

Ensure these are set in `.env` (already gitignored). Compose passes them through to containers.

---
## 10) Runtime Flow (HTTP)
1) Browser calls `https://localhost/auth/login` with creds.
2) Backend validates, issues JWTs.
3) Browser stores access token (and refresh token if used) and calls protected routes with `Authorization: Bearer <token>`.
4) Backend uses Prisma to read/write SQLite.
5) Responses are JSON. Static files (avatars) served from `/public/uploads/*` via Fastify static + proxied by nginx.

---
## 11) Runtime Flow (WebSockets)
1) Browser connects to `wss://localhost/ws/game`.
2) First message `{ type: "auth", token }` is required; server verifies JWT and stores the socket by userId.
3) Subsequent messages carry game actions/state; server can route/broadcast based on userId.

---
## 12) CORS & Same-Origin
- Backend enables CORS with credentials for the configured origin.
- Since nginx terminates TLS at `https://localhost`, set frontend API base to that and update Google OAuth origins/redirects to the same host.

---
## 13) Common Tasks
**Build & start (with SSL auto-gen)**
```bash
make up    # runs make ssl then docker-compose up -d
```

**Apply DB schema (accepting data-loss for ID migration)**
```bash
make data  # runs prisma db push --accept-data-loss and restarts backend
```

**Restart services**
```bash
make restart
```

**Follow logs**
```bash
make logs
```

**Full clean (removes volumes and SSL)**
```bash
make fclean
```

---
## 14) Security Notes
- Use strong, unique secrets for JWTs and Google credentials.
- Self-signed certs are for dev only; in prod use Let's Encrypt or a trusted CA.
- UUID user IDs reduce enumeration risk vs. incremental ints.
- Validate and sanitize all inputs (already present in routes; extend as needed).
- Limit CORS origins to trusted hosts in production.

---
## 15) Troubleshooting
- **SSL errors**: Ensure `srcs/nginx/ssl/server.crt` and `.key` exist; regenerate with the script; restart nginx.
- **Origin mismatch (Google OAuth)**: Set Authorized JavaScript Origin to `https://localhost` and Redirect URI to `https://localhost/auth/google/callback`.
- **DB schema change warnings**: Use `prisma db push --accept-data-loss` during dev; for prod create migrations.
- **WebSocket auth failing**: Verify the first message includes a valid access token; check `JWT_ACCESS_SECRET` matches backend.

---
## 16) Extending the System
- Split services into distinct containers with separate ports if scaling independently.
- Swap SQLite for Postgres by changing the Prisma datasource and connection string; run `prisma migrate`.
- Add rate limiting (e.g., `@fastify/rate-limit`) in `shared/fastify.ts`.
- Add request validation (e.g., JSON schemas) per route for stronger contracts.

---
## 17) Fastify Quick Primer
- **Route**: `app.get('/path', handler)`.
- **Plugin**: `app.register(plugin, options)` – used for CORS, JWT, static, websocket.
- **Reply**: `reply.status(200).send(body)`.
- **Decorators**: attach utilities to `app` (e.g., Prisma client via `decorate`).

---
## 18) JWT Quick Primer
- Structure: `header.payload.signature` (Base64URL).
- Signed with HMAC-SHA256 using server secret.
- Verification recalculates signature; any change to payload breaks validation.
- Expiry (`exp`) enforced by `@fastify/jwt`.

---
## 19) Prisma Quick Primer
- **Schema** defines models and relations.
- **Generate** client: `npx prisma generate` (done in Docker build).
- **Push** schema: `npx prisma db push` (syncs schema to DB).
- **Client use**: `app.prisma.user.findUnique({ where: { id } })`.

---
## 20) Docker Compose Quick Primer
- `services` define containers.
- `build` points to Dockerfile context.
- `ports` expose to host; `expose` only inside the bridge network.
- `depends_on` controls startup order (not health).
- `volumes` persist data or mount code.

---
## 21) Nginx Quick Primer
- `server` block listens on ports, sets `server_name`.
- `location` blocks route paths to upstreams with `proxy_pass`.
- SSL directives set cert/key and protocols.
- WebSocket requires `Upgrade` and `Connection` headers and usually `proxy_read_timeout` extended.

---
## 22) Where to Look in Code
- HTTP setup: `srcs/backend/shared/fastify.ts`
- Auth routes: `srcs/backend/auth/src/main.ts` and `routes/*.ts`
- JWT helpers: `srcs/backend/auth/src/utils/tokens.ts`
- User routes: `srcs/backend/user/src/main.ts`
- Game routes: `srcs/backend/game/src/main.ts`
- WebSocket gateway: `srcs/backend/ws-gateway/src/main.ts`
- Reverse proxy: `srcs/nginx/nginx.conf`
- Compose wiring: `srcs/docker-compose.yml`

---
## 23) Suggested Learning Path
1) Run `make up` and hit `https://localhost/auth/health` to confirm HTTPS + proxy.
2) Register/login, inspect JWT in browser devtools, and call a protected route.
3) Trigger a match POST via the frontend and see it appear in SQLite using `docker exec transcendence-backend npx prisma studio`.
4) Connect to `wss://localhost/ws/game` with a token to observe WS auth.
5) Swap SQLite for Postgres in a branch to practice DB portability.

---
## 24) Glossary (quick hits)
- **Bridge network**: Docker’s private switch for containers.
- **JWT**: signed token for stateless auth.
- **Fastify**: Node HTTP framework; fast and plugin-based.
- **Prisma**: ORM generating a typed client from schema.
- **SQLite**: file-based relational DB.
- **Reverse proxy**: front server that routes requests to internal services.
- **CORS**: browser policy; server opts-in to cross-origin requests.
- **WebSocket**: full-duplex TCP-over-HTTP upgrade.
- **HSTS**: header forcing HTTPS for a period.

---
## 25) Final Checklist for Dev
- `.env` filled with real secrets.
- Google OAuth origins/redirects set to `https://localhost` and `/auth/google/callback`.
- `make up` → services healthy.
- Accept browser warning for self-signed cert.
- Run `make data` after schema changes.

---
## 26) Theory Cheat Sheet (evaluation ready)
- **HTTP basics**: verbs (GET=read, POST=create, PUT/PATCH=update, DELETE=remove); status codes (2xx success, 4xx client error, 5xx server error); idempotency (GET/PUT/DELETE should be repeatable without side-effects beyond the first execution; POST is not idempotent by default).
- **REST conventions**: resource nouns (`/user/:id`), stateless requests, use of standard codes, pagination and filtering via query params.
- **TLS/HTTPS**: encrypts transport; cert proves server identity; HSTS forces HTTPS; self-signed certs warn because not trusted by a CA.
- **Reverse proxy (Nginx)**: terminates TLS, centralizes headers, does HTTP→HTTPS redirect, and routes paths to upstream services.
- **CORS**: browser enforcement that blocks cross-origin requests unless server allows `Origin` with proper `Access-Control-Allow-*` headers; not a security boundary for server-to-server calls.
- **JWT**: signed (not encrypted) token; contains claims (e.g., `userId`), verified with a shared secret; short-lived access tokens, longer refresh tokens; tampering breaks the signature.
- **OAuth2 vs OIDC**: OAuth2 is authZ (delegating access); OIDC layers identity on top (ID tokens) for login; Google sign-in here uses OAuth2 flow and returns an ID token we verify.
- **CSRF vs XSS**: CSRF abuses implicit auth (cookies); mitigated by same-site cookies, CSRF tokens, or using Authorization headers with CORS. XSS injects scripts; mitigated by escaping, CSP, and avoiding dangerous HTML injection.
- **WebSockets**: upgrade from HTTP to a persistent, full-duplex channel; keep-alive and backpressure matter; auth once, then reuse connection.
- **ORM (Prisma)**: schema-first modeling, generated client enforces types; advantages: safety and productivity; watch for N+1 queries, add indexes as needed.
- **Database consistency**: SQLite is ACID; transactions group operations atomically; with UUID primary keys we avoid predictable enumeration.
- **Indexes**: speed up lookups on selective columns (e.g., `username`, `email`); excessive indexes slow writes.
- **Rate limiting**: protects against abuse; can be added at Fastify or Nginx (not enabled by default here).
- **Logging and observability**: Fastify logger enabled; centralize logs at reverse proxy and app for debugging; health endpoints for liveness.
- **Error handling**: return meaningful 4xx/5xx codes and JSON bodies; do not leak secrets; validate inputs.
- **Security headers**: HSTS, X-Frame-Options, X-Content-Type-Options, X-XSS-Protection set at Nginx; consider CSP for stricter frontends.
- **Deployment posture**: Dev uses self-signed certs and SQLite; production should use trusted TLS (e.g., Let's Encrypt) and a managed DB (Postgres/MySQL) with migrations.

That’s the full backend walkthrough. Explore the referenced files to deepen understanding and extend the system safely.
